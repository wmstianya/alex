# STM32火焰检测系统 - 智能初始状态检测功能

## 🎯 解决的问题

**问题描述：**
- 正常情况下（无火焰）：ADC值在2600mV左右
- 有火焰时：ADC值在1500mV左右
- **关键问题：**如果上电时就有火焰，ADC采集到1400mV左右，系统会错误地将1400mV当作环境基线，导致后续无法正确检测火焰

## 🔧 解决方案

### 1. 智能初始状态检测
- **预期无火焰范围：**2200-2800mV
- **初始检查采样：**上电后先进行10次快速采样
- **状态判断：**
  - 如果ADC值在2200-2800mV范围内 → 初始状态有效，可以校准
  - 如果ADC值低于2200mV → 可能有火焰，需要等待
  - 如果ADC值高于2800mV → 可能传感器异常，但仍可校准

### 2. 校准重试机制
- **重试间隔：**3秒
- **最大重试次数：**5次
- **重试逻辑：**
  1. 检测到可能有火焰时，每3秒重新检查一次
  2. 如果连续5次都检测到火焰，使用安全基线值(2500mV)
  3. 动态阈值设置为：安全基线 - 300mV = 2200mV

### 3. 显示状态指示
- **正常校准：**显示实时电压值
- **检测到火焰：**闪烁显示"8888"错误代码
- **校准完成：**正常显示当前值

## 📋 工作流程

```
上电启动
    ↓
进行初始状态检查(10次采样)
    ↓
ADC值是否在2200-2800mV范围内？
    ↓
是  → 开始正常校准(50次采样)
    ↓
否  → 等待3秒后重试
    ↓
重试5次后仍有火焰？
    ↓
是  → 使用安全基线值(2500mV)
    ↓
否  → 继续重试
    ↓
校准完成，进入正常检测模式
```

## 🔍 关键参数

| 参数 | 数值 | 说明 |
|------|------|------|
| EXPECTED_NO_FLAME_MIN_MV | 2200mV | 预期无火焰最小值 |
| EXPECTED_NO_FLAME_MAX_MV | 2800mV | 预期无火焰最大值 |
| INITIAL_CHECK_SAMPLES | 10 | 初始状态检查采样数 |
| CALIBRATION_RETRY_DELAY | 3000ms | 校准重试延迟 |
| MAX_CALIBRATION_RETRIES | 5 | 最大重试次数 |

## 💡 优势

### 传统方案 vs 智能检测
| 特性 | 传统方案 | 智能检测 |
|------|----------|----------|
| 上电有火焰 | ❌ 错误校准，无法检测 | ✅ 智能识别，安全处理 |
| 校准可靠性 | ⚠️ 依赖初始环境 | ✅ 自动验证初始状态 |
| 错误恢复 | ❌ 需要重新上电 | ✅ 自动重试机制 |
| 状态提示 | ❌ 无明确提示 | ✅ 闪烁显示错误状态 |
| 安全性 | ⚠️ 可能误操作 | ✅ 安全基线兜底 |

## 🚨 状态代码

| 显示状态 | 含义 | 处理建议 |
|----------|------|----------|
| 实时电压值 | 正常校准中 | 等待校准完成 |
| 闪烁"8888" | 检测到火焰 | 请移除火焰后等待 |
| 闪烁"0000" | 重试等待中 | 系统正在重试 |
| 正常电压值 | 校准完成 | 系统正常工作 |

## 📝 使用说明

### 正常启动
1. 上电后系统自动进行初始状态检查
2. 如果环境正常，约2秒完成校准
3. 显示屏显示当前电压值，系统进入正常检测模式

### 上电时有火焰
1. 系统检测到火焰后，显示屏闪烁"8888"
2. 请移除火焰源，系统会自动重试
3. 3秒后重新检查，如果火焰消失则开始校准
4. 如果连续5次检测到火焰，系统使用安全基线值继续工作

### 故障排除
- **闪烁8888不停止：**检查是否有持续火焰源
- **显示000：**检查传感器连接
- **显示异常电压：**检查传感器和电路连接

## 🔧 技术细节

### 代码结构
```c
// 新增函数
static uint8_t checkInitialState(void);           // 初始状态检测
static uint8_t performInitialStateCheck(void);    // 校准重试逻辑
static void displayCalibrationStatus(uint8_t isValid); // 状态显示

// 新增状态
typedef enum {
    FLAME_NOT_DETECTED = 0,
    FLAME_DETECTED = 1,
    SENSOR_DISCONNECTED = 2,
    CALIBRATION_ERROR = 3       // 新增：校准错误状态
} FlameStatus_t;

// 新增数据结构字段
typedef struct {
    // ... 原有字段
    uint8_t  calibrationRetryCount;     // 校准重试计数
    uint32_t lastCalibrationRetry;      // 上次校准重试时间
    uint8_t  initialStateValid;         // 初始状态是否有效
} AdaptiveDetector_t;
```

### 安全机制
1. **多重检查：**初始状态检查 + 校准重试 + 安全基线
2. **状态指示：**明确的视觉反馈
3. **自动恢复：**无需人工干预的重试机制
4. **安全兜底：**最坏情况下使用安全基线值

## 📞 技术支持

如有疑问或需要进一步技术支持，请联系开发团队。

---

**版本信息：**
- 基础版本：V1.0.2
- 智能检测版本：V1.1.0
- 更新日期：2025年1月11日 

## 🔍 检查.gitignore状态

### 1. 检查.gitignore文件是否存在
```powershell
# 查看当前目录下是否有.gitignore文件
ls -la | findstr gitignore

# 或者
dir .gitignore

# 查看.gitignore内容
cat .gitignore
```

### 2. 检查.gitignore位置
```powershell
# .gitignore文件必须在Git仓库根目录
pwd
ls .gitignore
```

## 🚨 .gitignore不起作用的常见原因

### 原因1: 文件已经被Git跟踪了
如果文件在创建`.gitignore`之前就已经被`git add`了，需要先取消跟踪：

```powershell
# 查看哪些文件被跟踪
git status

# 取消跟踪特定文件（但保留本地文件）
git rm --cached filename

# 取消跟踪整个文件夹
git rm -r --cached foldername/

# 取消跟踪所有文件，重新按照.gitignore规则添加
git rm -r --cached .
git add .
```

### 原因2: .gitignore语法问题
```powershell
# 查看.gitignore内容
cat .gitignore

# 常见的正确格式示例：
# *.o          # 忽略所有.o文件
# *.log        # 忽略所有.log文件
# build/       # 忽略build目录
# !important.o # 但不忽略important.o
```

### 原因3: 文件在暂存区
```powershell
# 如果文件已经在暂存区，需要先移除
git reset filename
```

## 🔧 解决方案

### 创建或修改.gitignore文件
```powershell
<code_block_to_apply_changes_from>
```

### 清理已跟踪的文件
```powershell
# 1. 移除所有已跟踪的文件
git rm -r --cached .

# 2. 重新添加（会按照.gitignore规则）
git add .

# 3. 查看状态
git status

# 4. 提交更改
git commit -m "应用.gitignore规则"
```

## 📋 完整诊断步骤

```powershell
# 1. 检查.gitignore是否存在
ls -la .gitignore

# 2. 查看内容
cat .gitignore

# 3. 查看Git状态
git status

# 4. 查看哪些文件被忽略了
git status --ignored

# 5. 测试特定文件是否被忽略
git check-ignore -v filename
```

请告诉我：
1. 您想忽略哪些类型的文件？
2. 当前`git status`显示什么？
3. `.gitignore`文件是否存在？

我会根据具体情况帮您解决！
